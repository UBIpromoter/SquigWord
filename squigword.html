<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SquigWord</title>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0d0d0f;
            --card: #161619;
            --input: #1e1e22;
            --text: #ffffff;
            --dim: #9ca3af;
            --muted: #6b7280;
            --accent: #a855f7;
            --glow: rgba(168, 85, 247, 0.2);
            --border: rgba(255, 255, 255, 0.08);
        }
        .light-mode {
            --bg: #f5f5f7;
            --card: #ffffff;
            --input: #f0f0f2;
            --text: #1a1a1a;
            --dim: #4b5563;
            --muted: #6b7280;
            --accent: #7c3aed;
            --glow: rgba(124, 58, 237, 0.15);
            --border: rgba(0, 0, 0, 0.08);
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { overflow-x: hidden; }
        body {
            font-family: 'Space Grotesk', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .app { max-width: 880px; width: 100%; margin: 0 auto; padding: 12px 16px; display: flex; flex-direction: column; min-height: 100vh; }
        .canvas-wrap { background: var(--card); border: 1px solid var(--border); border-radius: 10px; padding: 6px; margin-bottom: 10px; position: relative; flex-shrink: 0; }
        canvas { width: 100%; display: block; border-radius: 6px; cursor: pointer; }
        .panel { background: var(--card); border: 1px solid var(--border); border-radius: 10px; padding: 16px 20px; flex-shrink: 0; }
        .field { margin-bottom: 14px; }
        .field:last-child { margin-bottom: 0; }
        .field-label { display: block; font-size: 11px; font-weight: 600; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; }
        .field-row { display: flex; gap: 16px; margin-bottom: 14px; }
        .flex-grow { flex: 1; min-width: 0; }
        .input-group { display: flex; gap: 6px; align-items: center; }
        input[type="text"], input[type="number"] { background: var(--input); border: 1px solid var(--border); border-radius: 6px; padding: 10px 12px; font-size: 16px; font-family: inherit; color: var(--text); outline: none; transition: border 0.15s; }
        input:focus { border-color: var(--accent); }
        input[type="text"] { flex: 1; min-width: 0; }
        input[type="number"] { width: 100px; font-family: 'JetBrains Mono', monospace; text-align: center; }
        .btn-row { display: flex; flex-wrap: wrap; gap: 6px; }
        .btn { padding: 8px 14px; border-radius: 6px; font-size: 14px; font-weight: 500; font-family: inherit; cursor: pointer; border: 1px solid var(--border); background: var(--input); color: var(--dim); transition: all 0.12s; white-space: nowrap; }
        .btn:hover { background: var(--bg); color: var(--text); }
        .btn.active { background: rgba(168, 85, 247, 0.35); border-color: rgba(168, 85, 247, 0.5); color: #e9d5ff; }
        .light-mode .btn.active { background: rgba(124, 58, 237, 0.2); border-color: rgba(124, 58, 237, 0.4); color: #6d28d9; }
        .icon-btn { width: 38px; height: 38px; border-radius: 6px; border: 1px solid var(--border); background: var(--card); color: var(--muted); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 16px; transition: all 0.15s; }
        .icon-btn:hover { background: var(--glow); border-color: var(--accent); color: var(--text); }
        .icon-btn.playing { background: var(--accent); color: white; }
        .traits { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; font-size: 14px; color: var(--muted); padding-top: 8px; }
        .trait-val { font-weight: 600; color: var(--text); margin-right: 2px; }
        .color-dot { width: 14px; height: 14px; border-radius: 50%; display: inline-block; vertical-align: middle; }
        .action-row { display: flex; gap: 8px; margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border); align-items: center; }
        .speed-control { display: flex; align-items: center; gap: 6px; margin-left: 8px; }
        .speed-control label { font-size: 11px; color: var(--muted); }
        .speed-slider { width: 80px; height: 4px; -webkit-appearance: none; background: var(--border); border-radius: 2px; outline: none; }
        .speed-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: var(--accent); border-radius: 50%; cursor: pointer; }
        .footer { text-align: center; padding: 8px; font-size: 12px; color: var(--muted); flex-shrink: 0; margin-top: auto; }
    </style>
</head>
<body>
    <div class="app">
        <div class="canvas-wrap"><canvas id="canvas" width="860" height="280"></canvas></div>
        <div class="panel">
            <div class="field-row">
                <div class="field flex-grow">
                    <label class="field-label">TEXT</label>
                    <div class="input-group">
                        <input type="text" id="textInput" value="Squiggles" maxlength="20" spellcheck="false">
                        <button class="icon-btn" id="randWordBtn" title="Random word">&#8635;</button>
                    </div>
                </div>
                <div class="field">
                    <label class="field-label">SEED</label>
                    <div class="input-group">
                        <input type="number" id="seedInput" value="42">
                        <button class="icon-btn" id="randSeedBtn" title="Random seed">&#8635;</button>
                    </div>
                </div>
            </div>
            <div class="field">
                <label class="field-label">TYPE</label>
                <div class="btn-row" id="typeBtns"></div>
            </div>
            <div class="field">
                <label class="field-label">FONT</label>
                <div class="btn-row" id="fontBtns"></div>
            </div>
            <div class="traits" id="traits"></div>
            <div class="action-row">
                <button class="icon-btn" id="modeToggle" title="Toggle light/dark">&#9728;</button>
                <button class="icon-btn" id="animateBtn" title="Watch it draw">&#9654;</button>
                <div class="speed-control">
                    <label>Speed</label>
                    <input type="range" class="speed-slider" id="speedSlider" min="1" max="20" value="10">
                </div>
                <button class="icon-btn" id="downloadBtn" title="Download PNG" style="margin-left:auto;">&#8595;</button>
            </div>
        </div>
        <footer class="footer">SquigWord &middot; inspired by <span class="credit">snowfro</span></footer>
    </div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// State
const state = {
    text: 'Squiggles',
    seed: 42,
    forceType: 'Auto',
    fontStyle: 'Smooth',
    bgIndex: 7,
    darkMode: true,
    animOffset: 0,
    drawAnimating: false,
    drawProgress: 0,
    drawSpeed: 10
};

const BACKGROUNDS = ['#ffffff','#f5f5f5','#e0e0e0','#c0c0c0','#808080','#404040','#202020','#000000'];
const TYPES = ['Auto', 'Normal', 'Bold', 'Slinky', 'Pipe', 'Fuzzy', 'Ribbed'];

// ============================================
// SINGLE-STROKE CURSIVE FONTS (from vF)
// Each letter is a path through the CENTER, not an outline
// ============================================

const FONT_SMOOTH = {
    'a': { path: [[.1,.6],[.18,.45],[.4,.38],[.65,.48],[.7,.7],[.6,.92],[.38,.98],[.2,.85],[.18,.65],[.3,.5],[.6,.5],[.7,.65],[.75,.88],[.9,.82]], entry: {x:.1,y:.6,angle:55}, exit: {x:.9,y:.82,angle:20}, width:.85 },
    'b': { path: [[.15,.92],[.18,.5],[.2,.15],[.22,.02],[.2,.25],[.2,.6],[.38,.42],[.65,.45],[.78,.65],[.72,.88],[.48,.98],[.25,.88],[.22,.65],[.45,.5],[.72,.48]], entry: {x:.15,y:.92,angle:85}, exit: {x:.72,y:.48,angle:10}, width:.8 },
    'c': { path: [[.8,.48],[.55,.38],[.25,.5],[.22,.75],[.38,.95],[.65,.95],[.85,.85]], entry: {x:.8,y:.48,angle:-25}, exit: {x:.85,y:.85,angle:25}, width:.8 },
    'd': { path: [[.1,.6],[.2,.45],[.42,.38],[.62,.5],[.65,.72],[.55,.92],[.35,.98],[.2,.85],[.22,.6],[.5,.45],[.72,.35],[.75,.1],[.72,.02],[.72,.4],[.72,.75],[.8,.92],[.92,.85]], entry: {x:.1,y:.6,angle:55}, exit: {x:.92,y:.85,angle:18}, width:.9 },
    'e': { path: [[.18,.68],[.35,.55],[.55,.48],[.75,.55],[.78,.68],[.5,.68],[.22,.72],[.25,.9],[.5,.98],[.78,.9],[.9,.82]], entry: {x:.18,y:.68,angle:60}, exit: {x:.9,y:.82,angle:20}, width:.85 },
    'f': { path: [[.72,.08],[.5,.02],[.38,.15],[.38,.5],[.38,.85],[.4,1.05],[.5,1.18],[.62,1.1]], crossbar: [[.2,.52],[.6,.52]], entry: {x:.72,y:.08,angle:-50}, exit: {x:.62,y:1.1,angle:-30}, width:.65, descender:true },
    'g': { path: [[.12,.6],[.22,.45],[.45,.38],[.68,.5],[.7,.72],[.58,.92],[.38,.98],[.22,.85],[.25,.6],[.55,.5],[.7,.58],[.72,.85],[.7,1.15],[.55,1.35],[.35,1.32],[.28,1.15]], entry: {x:.12,y:.6,angle:55}, exit: {x:.28,y:1.15,angle:100}, width:.82, descender:true },
    'h': { path: [[.12,.92],[.15,.5],[.18,.15],[.2,.02],[.18,.3],[.18,.65],[.22,.88],[.28,.65],[.45,.48],[.68,.52],[.75,.72],[.78,.92],[.9,.85]], entry: {x:.12,y:.92,angle:85}, exit: {x:.9,y:.85,angle:18}, width:.88 },
    'i': { path: [[.35,.48],[.42,.65],[.48,.85],[.55,.95],[.7,.88]], dot: [.45,.2], entry: {x:.35,y:.48,angle:60}, exit: {x:.7,y:.88,angle:18}, width:.55 },
    'j': { path: [[.45,.48],[.5,.7],[.52,.95],[.5,1.18],[.38,1.35],[.22,1.28]], dot: [.5,.2], entry: {x:.45,y:.48,angle:65}, exit: {x:.22,y:1.28,angle:150}, width:.5, descender:true },
    'k': { path: [[.12,.92],[.15,.5],[.18,.15],[.2,.02],[.18,.35],[.18,.7],[.2,.92],[.2,.62],[.5,.42],[.7,.38],[.2,.62],[.55,.82],[.78,.95],[.88,.88]], entry: {x:.12,y:.92,angle:85}, exit: {x:.88,y:.88,angle:15}, width:.85 },
    'l': { path: [[.3,.92],[.35,.5],[.38,.15],[.4,.02],[.38,.35],[.4,.7],[.45,.92],[.58,.95],[.72,.88]], entry: {x:.3,y:.92,angle:85}, exit: {x:.72,y:.88,angle:15}, width:.6 },
    'm': { path: [[.05,.92],[.08,.6],[.1,.48],[.1,.7],[.12,.9],[.18,.65],[.32,.48],[.42,.55],[.45,.75],[.45,.9],[.5,.65],[.62,.48],[.75,.55],[.78,.75],[.82,.92],[.92,.85]], entry: {x:.05,y:.92,angle:85}, exit: {x:.92,y:.85,angle:18}, width:1.05 },
    'n': { path: [[.1,.92],[.12,.6],[.15,.48],[.15,.72],[.18,.9],[.25,.65],[.45,.48],[.65,.55],[.72,.75],[.78,.92],[.9,.85]], entry: {x:.1,y:.92,angle:85}, exit: {x:.9,y:.85,angle:18}, width:.88 },
    'o': { path: [[.2,.65],[.28,.48],[.5,.42],[.72,.52],[.78,.72],[.7,.92],[.48,.98],[.28,.88],[.22,.68],[.35,.52],[.6,.48],[.78,.55]], entry: {x:.2,y:.65,angle:70}, exit: {x:.78,y:.55,angle:10}, width:.82 },
    'p': { path: [[.12,.48],[.15,.7],[.18,.95],[.2,1.2],[.22,1.38],[.2,1.1],[.2,.75],[.2,.55],[.4,.42],[.65,.48],[.75,.68],[.68,.9],[.45,.98],[.25,.88],[.2,.7]], entry: {x:.12,y:.48,angle:60}, exit: {x:.2,y:.7,angle:-70}, width:.78, descender:true },
    'q': { path: [[.15,.62],[.25,.48],[.5,.42],[.7,.55],[.75,.75],[.65,.92],[.42,.98],[.25,.85],[.28,.62],[.55,.5],[.72,.55],[.75,.8],[.78,1.1],[.82,1.3],[.9,1.22]], entry: {x:.15,y:.62,angle:65}, exit: {x:.9,y:1.22,angle:-25}, width:.85, descender:true },
    'r': { path: [[.12,.92],[.15,.62],[.18,.48],[.18,.72],[.2,.9],[.28,.62],[.48,.45],[.7,.48],[.82,.55]], entry: {x:.12,y:.92,angle:85}, exit: {x:.82,y:.55,angle:8}, width:.75 },
    's': { path: [[.75,.48],[.5,.4],[.3,.48],[.28,.6],[.45,.68],[.65,.75],[.72,.85],[.58,.98],[.35,.95],[.25,.85],[.55,.88],[.8,.82]], entry: {x:.75,y:.48,angle:-25}, exit: {x:.8,y:.82,angle:15}, width:.78 },
    't': { path: [[.4,.15],[.42,.45],[.45,.75],[.5,.95],[.65,.95],[.78,.88]], crossbar: [[.22,.48],[.62,.48]], entry: {x:.4,y:.15,angle:70}, exit: {x:.78,y:.88,angle:15}, width:.65 },
    'u': { path: [[.1,.48],[.12,.7],[.18,.9],[.38,.98],[.6,.9],[.72,.7],[.72,.52],[.72,.72],[.78,.92],[.9,.85]], entry: {x:.1,y:.48,angle:60}, exit: {x:.9,y:.85,angle:18}, width:.88 },
    'v': { path: [[.1,.48],[.25,.7],[.42,.9],[.5,.98],[.58,.9],[.75,.7],[.9,.5]], entry: {x:.1,y:.48,angle:50}, exit: {x:.9,y:.5,angle:-35}, width:.85 },
    'w': { path: [[.05,.48],[.15,.75],[.25,.95],[.32,.78],[.42,.55],[.5,.78],[.6,.95],[.7,.75],[.82,.55],[.92,.5]], entry: {x:.05,y:.48,angle:55}, exit: {x:.92,y:.5,angle:-25}, width:1.0 },
    'x': { path: [[.15,.48],[.35,.65],[.5,.75],[.65,.88],[.82,.95]], path2: [[.82,.48],[.65,.62],[.5,.75],[.35,.88],[.18,.95]], entry: {x:.15,y:.48,angle:45}, exit: {x:.18,y:.95,angle:200}, width:.85 },
    'y': { path: [[.1,.48],[.28,.72],[.45,.92],[.58,.72],[.72,.52],[.72,.75],[.65,1.0],[.5,1.25],[.32,1.35],[.2,1.22]], entry: {x:.1,y:.48,angle:55}, exit: {x:.2,y:1.22,angle:130}, width:.8, descender:true },
    'z': { path: [[.2,.48],[.5,.48],[.78,.5],[.5,.72],[.22,.95],[.5,.98],[.82,.92]], entry: {x:.2,y:.48,angle:5}, exit: {x:.82,y:.92,angle:18}, width:.8 },
    'A': { path: [[.05,.98],[.25,.6],[.42,.25],[.5,.05],[.58,.25],[.75,.6],[.95,.98]], crossbar: [[.25,.65],[.75,.65]], entry: {x:.05,y:.98,angle:70}, exit: {x:.95,y:.98,angle:-70}, width:.95 },
    'B': { path: [[.1,.98],[.1,.5],[.1,.02],[.5,.02],[.7,.12],[.7,.3],[.5,.42],[.1,.42],[.55,.42],[.75,.55],[.75,.8],[.55,.98],[.1,.98]], entry: {x:.1,y:.98,angle:90}, exit: {x:.1,y:.98,angle:0}, width:.85 },
    'C': { path: [[.88,.18],[.65,.02],[.35,.02],[.12,.2],[.08,.5],[.12,.8],[.35,.98],[.65,.98],[.88,.82]], entry: {x:.88,y:.18,angle:-60}, exit: {x:.88,y:.82,angle:60}, width:.9 },
    'D': { path: [[.1,.98],[.1,.5],[.1,.02],[.45,.02],[.75,.2],[.82,.5],[.75,.8],[.45,.98],[.1,.98]], entry: {x:.1,y:.98,angle:90}, exit: {x:.1,y:.98,angle:0}, width:.88 },
    'E': { path: [[.85,.02],[.4,.02],[.1,.02],[.1,.5],[.6,.5],[.1,.5],[.1,.98],[.4,.98],[.85,.98]], entry: {x:.85,y:.02,angle:180}, exit: {x:.85,y:.98,angle:0}, width:.82 },
    'F': { path: [[.85,.02],[.4,.02],[.1,.02],[.1,.5],[.6,.5],[.1,.5],[.1,.98]], entry: {x:.85,y:.02,angle:180}, exit: {x:.1,y:.98,angle:-90}, width:.78 },
    'G': { path: [[.88,.18],[.65,.02],[.35,.02],[.12,.2],[.08,.5],[.12,.8],[.35,.98],[.65,.98],[.88,.78],[.88,.55],[.55,.55]], entry: {x:.88,y:.18,angle:-60}, exit: {x:.55,y:.55,angle:180}, width:.92 },
    'H': { path: [[.1,.02],[.1,.5],[.1,.98],[.1,.5],[.9,.5],[.9,.02],[.9,.5],[.9,.98]], entry: {x:.1,y:.02,angle:-90}, exit: {x:.9,y:.98,angle:-90}, width:.9 },
    'I': { path: [[.25,.02],[.5,.02],[.75,.02],[.5,.02],[.5,.5],[.5,.98],[.25,.98],[.5,.98],[.75,.98]], entry: {x:.25,y:.02,angle:0}, exit: {x:.75,y:.98,angle:0}, width:.55 },
    'J': { path: [[.2,.02],[.5,.02],[.75,.02],[.75,.5],[.75,.8],[.6,.98],[.35,.98],[.15,.85]], entry: {x:.2,y:.02,angle:0}, exit: {x:.15,y:.85,angle:150}, width:.75 },
    'K': { path: [[.1,.02],[.1,.5],[.1,.98],[.1,.5],[.8,.02],[.1,.5],[.8,.98]], entry: {x:.1,y:.02,angle:-90}, exit: {x:.8,y:.98,angle:-60}, width:.82 },
    'L': { path: [[.1,.02],[.1,.5],[.1,.98],[.5,.98],[.88,.98]], entry: {x:.1,y:.02,angle:-90}, exit: {x:.88,y:.98,angle:0}, width:.78 },
    'M': { path: [[.05,.98],[.05,.5],[.05,.02],[.35,.5],[.5,.72],[.65,.5],[.95,.02],[.95,.5],[.95,.98]], entry: {x:.05,y:.98,angle:90}, exit: {x:.95,y:.98,angle:-90}, width:1.05 },
    'N': { path: [[.1,.98],[.1,.5],[.1,.02],[.5,.5],[.9,.98],[.9,.5],[.9,.02]], entry: {x:.1,y:.98,angle:90}, exit: {x:.9,y:.02,angle:90}, width:.9 },
    'O': { path: [[.5,.02],[.2,.15],[.08,.5],[.2,.85],[.5,.98],[.8,.85],[.92,.5],[.8,.15],[.5,.02]], entry: {x:.5,y:.02,angle:180}, exit: {x:.5,y:.02,angle:0}, width:.95 },
    'P': { path: [[.1,.98],[.1,.5],[.1,.02],[.55,.02],[.78,.15],[.78,.35],[.55,.5],[.1,.5]], entry: {x:.1,y:.98,angle:90}, exit: {x:.1,y:.5,angle:0}, width:.8 },
    'Q': { path: [[.5,.02],[.2,.15],[.08,.5],[.2,.85],[.5,.98],[.8,.85],[.92,.5],[.8,.15],[.5,.02],[.6,.78],[.88,1.05]], entry: {x:.5,y:.02,angle:180}, exit: {x:.88,y:1.05,angle:-45}, width:.95 },
    'R': { path: [[.1,.98],[.1,.5],[.1,.02],[.55,.02],[.78,.15],[.78,.35],[.55,.5],[.1,.5],[.55,.5],[.85,.98]], entry: {x:.1,y:.98,angle:90}, exit: {x:.85,y:.98,angle:-60}, width:.85 },
    'S': { path: [[.82,.15],[.6,.02],[.35,.05],[.15,.2],[.18,.38],[.45,.5],[.7,.6],[.82,.78],[.7,.95],[.4,.98],[.15,.88]], entry: {x:.82,y:.15,angle:-70}, exit: {x:.15,y:.88,angle:210}, width:.82 },
    'T': { path: [[.05,.02],[.5,.02],[.95,.02],[.5,.02],[.5,.5],[.5,.98]], entry: {x:.05,y:.02,angle:0}, exit: {x:.5,y:.98,angle:-90}, width:.88 },
    'U': { path: [[.1,.02],[.1,.5],[.1,.78],[.25,.95],[.5,.98],[.75,.95],[.9,.78],[.9,.5],[.9,.02]], entry: {x:.1,y:.02,angle:-90}, exit: {x:.9,y:.02,angle:90}, width:.9 },
    'V': { path: [[.05,.02],[.28,.4],[.5,.98],[.72,.4],[.95,.02]], entry: {x:.05,y:.02,angle:-60}, exit: {x:.95,y:.02,angle:60}, width:.92 },
    'W': { path: [[.02,.02],[.18,.6],[.3,.98],[.42,.55],[.5,.3],[.58,.55],[.7,.98],[.82,.6],[.98,.02]], entry: {x:.02,y:.02,angle:-70}, exit: {x:.98,y:.02,angle:70}, width:1.1 },
    'X': { path: [[.1,.02],[.35,.3],[.5,.5],[.65,.7],[.9,.98]], path2: [[.9,.02],[.65,.3],[.5,.5],[.35,.7],[.1,.98]], entry: {x:.1,y:.02,angle:-45}, exit: {x:.1,y:.98,angle:225}, width:.88 },
    'Y': { path: [[.1,.02],[.3,.25],[.5,.5],[.7,.25],[.9,.02],[.5,.5],[.5,.75],[.5,.98]], entry: {x:.1,y:.02,angle:-55}, exit: {x:.5,y:.98,angle:-90}, width:.88 },
    'Z': { path: [[.1,.02],[.5,.02],[.9,.02],[.5,.5],[.1,.98],[.5,.98],[.9,.98]], entry: {x:.1,y:.02,angle:0}, exit: {x:.9,y:.98,angle:0}, width:.85 },
    '0': { path: [[.5,.02],[.22,.18],[.12,.5],[.22,.82],[.5,.98],[.78,.82],[.88,.5],[.78,.18],[.5,.02]], entry: {x:.5,y:.02,angle:180}, exit: {x:.5,y:.02,angle:0}, width:.85 },
    '1': { path: [[.3,.18],[.5,.02],[.5,.5],[.5,.98],[.3,.98],[.7,.98]], entry: {x:.3,y:.18,angle:45}, exit: {x:.7,y:.98,angle:0}, width:.55 },
    '2': { path: [[.15,.2],[.35,.02],[.65,.05],[.8,.2],[.7,.42],[.4,.65],[.15,.98],[.85,.98]], entry: {x:.15,y:.2,angle:60}, exit: {x:.85,y:.98,angle:0}, width:.82 },
    '3': { path: [[.15,.12],[.45,.02],[.75,.15],[.72,.38],[.5,.5],[.75,.62],[.72,.85],[.45,.98],[.15,.88]], entry: {x:.15,y:.12,angle:30}, exit: {x:.15,y:.88,angle:210}, width:.8 },
    '4': { path: [[.7,.98],[.7,.5],[.7,.02],[.15,.68],[.85,.68]], entry: {x:.7,y:.98,angle:90}, exit: {x:.85,y:.68,angle:0}, width:.82 },
    '5': { path: [[.8,.02],[.3,.02],[.2,.02],[.18,.28],[.25,.48],[.6,.48],[.8,.62],[.75,.85],[.5,.98],[.2,.88]], entry: {x:.8,y:.02,angle:180}, exit: {x:.2,y:.88,angle:210}, width:.8 },
    '6': { path: [[.78,.12],[.5,.02],[.22,.18],[.12,.5],[.22,.82],[.5,.98],[.78,.82],[.78,.62],[.5,.48],[.22,.62]], entry: {x:.78,y:.12,angle:-70}, exit: {x:.22,y:.62,angle:135}, width:.82 },
    '7': { path: [[.15,.02],[.5,.02],[.85,.02],[.55,.5],[.4,.98]], entry: {x:.15,y:.02,angle:0}, exit: {x:.4,y:.98,angle:-80}, width:.78 },
    '8': { path: [[.5,.5],[.28,.38],[.25,.2],[.4,.05],[.6,.05],[.75,.2],[.72,.38],[.5,.5],[.25,.62],[.2,.8],[.4,.98],[.6,.98],[.8,.8],[.75,.62],[.5,.5]], entry: {x:.5,y:.5,angle:135}, exit: {x:.5,y:.5,angle:-45}, width:.82 },
    '9': { path: [[.22,.88],[.5,.98],[.78,.82],[.88,.5],[.78,.18],[.5,.02],[.22,.18],[.22,.38],[.5,.52],[.78,.38]], entry: {x:.22,y:.88,angle:70}, exit: {x:.78,y:.38,angle:-45}, width:.82 },
    ' ': { path: [], entry: {x:0,y:.85,angle:0}, exit: {x:1,y:.85,angle:0}, width:.35 },
    '.': { path: [[.5,.92],[.5,.98]], entry: {x:.5,y:.92,angle:-90}, exit: {x:.5,y:.98,angle:-90}, width:.3 },
    ',': { path: [[.5,.88],[.45,.98],[.35,1.12]], entry: {x:.5,y:.88,angle:-60}, exit: {x:.35,y:1.12,angle:210}, width:.3 },
    '!': { path: [[.5,.02],[.5,.35],[.5,.62]], dot: [.5,.9], entry: {x:.5,y:.02,angle:-90}, exit: {x:.5,y:.62,angle:-90}, width:.35 },
    '?': { path: [[.2,.15],[.5,.02],[.8,.15],[.78,.35],[.5,.55],[.5,.65]], dot: [.5,.9], entry: {x:.2,y:.15,angle:45}, exit: {x:.5,y:.65,angle:-90}, width:.7 },
    '-': { path: [[.2,.52],[.8,.52]], entry: {x:.2,y:.52,angle:0}, exit: {x:.8,y:.52,angle:0}, width:.6 },
    "'": { path: [[.5,.02],[.45,.18]], entry: {x:.5,y:.02,angle:-70}, exit: {x:.45,y:.18,angle:-70}, width:.25 }
};

// Blockier/Angular font
const FONT_ANGULAR = {
    'a': { path: [[.15,.5],[.15,.98],[.15,.7],[.35,.5],[.65,.5],[.85,.7],[.85,.5],[.85,.98]], entry: {x:.15,y:.5,angle:-90}, exit: {x:.85,y:.98,angle:-90}, width:.85 },
    'b': { path: [[.15,.02],[.15,.98],[.65,.98],[.85,.78],[.85,.55],[.65,.4],[.15,.5]], entry: {x:.15,y:.02,angle:-90}, exit: {x:.15,y:.5,angle:0}, width:.85 },
    'c': { path: [[.85,.45],[.35,.45],[.15,.6],[.15,.85],[.35,.98],[.85,.98]], entry: {x:.85,y:.45,angle:180}, exit: {x:.85,y:.98,angle:0}, width:.82 },
    'd': { path: [[.85,.02],[.85,.98],[.35,.98],[.15,.78],[.15,.55],[.35,.4],[.85,.5]], entry: {x:.85,y:.02,angle:-90}, exit: {x:.85,y:.5,angle:0}, width:.85 },
    'e': { path: [[.15,.65],[.85,.65],[.85,.5],[.35,.45],[.15,.6],[.15,.85],[.35,.98],[.85,.98]], entry: {x:.15,y:.65,angle:0}, exit: {x:.85,y:.98,angle:0}, width:.85 },
    'f': { path: [[.7,.08],[.45,.02],[.35,.15],[.35,.98]], crossbar: [[.15,.48],[.55,.48]], entry: {x:.7,y:.08,angle:-135}, exit: {x:.35,y:.98,angle:-90}, width:.6 },
    'g': { path: [[.85,.55],[.5,.42],[.15,.6],[.15,.85],[.5,.98],[.85,.85],[.85,1.15],[.5,1.35],[.2,1.25]], entry: {x:.85,y:.55,angle:150}, exit: {x:.2,y:1.25,angle:180}, width:.85, descender:true },
    'h': { path: [[.15,.02],[.15,.98],[.15,.55],[.4,.42],[.85,.55],[.85,.98]], entry: {x:.15,y:.02,angle:-90}, exit: {x:.85,y:.98,angle:-90}, width:.88 },
    'i': { path: [[.5,.42],[.5,.98]], dot: [.5,.2], entry: {x:.5,y:.42,angle:-90}, exit: {x:.5,y:.98,angle:-90}, width:.4 },
    'j': { path: [[.55,.42],[.55,1.2],[.25,1.35]], dot: [.55,.2], entry: {x:.55,y:.42,angle:-90}, exit: {x:.25,y:1.35,angle:180}, width:.5, descender:true },
    'k': { path: [[.15,.02],[.15,.98],[.15,.6],[.7,.4],[.15,.6],[.75,.98]], entry: {x:.15,y:.02,angle:-90}, exit: {x:.75,y:.98,angle:-60}, width:.78 },
    'l': { path: [[.4,.02],[.4,.9],[.55,.98],[.7,.92]], entry: {x:.4,y:.02,angle:-90}, exit: {x:.7,y:.92,angle:20}, width:.55 },
    'm': { path: [[.08,.42],[.08,.98],[.08,.55],[.3,.42],[.5,.55],[.5,.98],[.5,.55],[.7,.42],[.92,.55],[.92,.98]], entry: {x:.08,y:.42,angle:-90}, exit: {x:.92,y:.98,angle:-90}, width:1.05 },
    'n': { path: [[.15,.42],[.15,.98],[.15,.55],[.4,.42],[.85,.55],[.85,.98]], entry: {x:.15,y:.42,angle:-90}, exit: {x:.85,y:.98,angle:-90}, width:.88 },
    'o': { path: [[.5,.42],[.15,.55],[.15,.85],[.5,.98],[.85,.85],[.85,.55],[.5,.42]], entry: {x:.5,y:.42,angle:180}, exit: {x:.5,y:.42,angle:0}, width:.85 },
    'p': { path: [[.15,.42],[.15,1.38],[.15,.85],[.15,.55],[.4,.42],[.85,.55],[.85,.85],[.5,.98],[.15,.85]], entry: {x:.15,y:.42,angle:-90}, exit: {x:.15,y:.85,angle:0}, width:.82, descender:true },
    'q': { path: [[.85,.42],[.85,1.38],[.85,.85],[.85,.55],[.6,.42],[.15,.55],[.15,.85],[.5,.98],[.85,.85]], entry: {x:.85,y:.42,angle:-90}, exit: {x:.85,y:.85,angle:0}, width:.82, descender:true },
    'r': { path: [[.2,.42],[.2,.98],[.2,.55],[.5,.42],[.85,.48]], entry: {x:.2,y:.42,angle:-90}, exit: {x:.85,y:.48,angle:0}, width:.75 },
    's': { path: [[.8,.45],[.2,.45],[.2,.65],[.8,.75],[.8,.98],[.2,.98]], entry: {x:.8,y:.45,angle:180}, exit: {x:.2,y:.98,angle:180}, width:.78 },
    't': { path: [[.4,.12],[.4,.9],[.55,.98],[.7,.92]], crossbar: [[.2,.45],[.6,.45]], entry: {x:.4,y:.12,angle:-90}, exit: {x:.7,y:.92,angle:20}, width:.6 },
    'u': { path: [[.15,.42],[.15,.85],[.5,.98],[.85,.85],[.85,.42],[.85,.98]], entry: {x:.15,y:.42,angle:-90}, exit: {x:.85,y:.98,angle:-90}, width:.88 },
    'v': { path: [[.1,.42],[.5,.98],[.9,.42]], entry: {x:.1,y:.42,angle:-60}, exit: {x:.9,y:.42,angle:60}, width:.85 },
    'w': { path: [[.05,.42],[.25,.98],[.5,.55],[.75,.98],[.95,.42]], entry: {x:.05,y:.42,angle:-70}, exit: {x:.95,y:.42,angle:70}, width:1.0 },
    'x': { path: [[.15,.42],[.5,.7],[.85,.98]], path2: [[.85,.42],[.5,.7],[.15,.98]], entry: {x:.15,y:.42,angle:-45}, exit: {x:.15,y:.98,angle:225}, width:.85 },
    'y': { path: [[.15,.42],[.5,.85],[.85,.42]], path2: [[.5,.85],[.35,1.15],[.2,1.35]], entry: {x:.15,y:.42,angle:-60}, exit: {x:.2,y:1.35,angle:-130}, width:.85, descender:true },
    'z': { path: [[.15,.42],[.85,.42],[.15,.98],[.85,.98]], entry: {x:.15,y:.42,angle:0}, exit: {x:.85,y:.98,angle:0}, width:.8 },
    ' ': { path: [], entry: {x:0,y:.85,angle:0}, exit: {x:1,y:.85,angle:0}, width:.35 },
    '.': { path: [[.5,.9],[.5,.98]], entry: {x:.5,y:.9,angle:-90}, exit: {x:.5,y:.98,angle:-90}, width:.3 },
    '!': { path: [[.5,.02],[.5,.62]], dot: [.5,.9], entry: {x:.5,y:.02,angle:-90}, exit: {x:.5,y:.62,angle:-90}, width:.35 }
};

// ============================================
// HERSHEY CURSIVE FONT DATA
// Single-stroke flowing cursive - the correct variant for squiggles
// ============================================

// Hershey CURSIVE font data - actual flowing cursive letters
// Raw coordinates from Hershey cursive variant, will be normalized below
const HERSHEY_CURSIVE_RAW = {
    'a': { main: [[9,16],[8,14],[6,13],[4,13],[2,14],[1,15],[0,17],[0,19],[1,21],[3,22],[5,22],[7,21],[8,19],[10,13],[9,18],[9,21],[10,22],[11,22],[13,21],[14,20],[16,17]], width: 18 },
    'b': { main: [[4,1],[2,3],[0,8],[0,13],[1,17],[2,19],[4,21],[6,22],[8,22],[10,21],[11,19],[11,17],[10,15],[8,14],[5,14],[6,1],[6,14]], width: 13 },
    'c': { main: [[11,14],[10,13],[8,13],[5,14],[3,16],[2,18],[2,20],[3,22],[6,22],[8,21],[9,20],[11,17]], width: 13 },
    'd': { main: [[11,1],[11,22],[11,14],[10,13],[8,13],[5,14],[3,16],[2,18],[2,20],[3,22],[5,22],[8,21],[11,17],[12,22],[13,22],[15,21],[16,20],[18,17]], width: 20 },
    'e': { main: [[1,20],[3,19],[4,18],[5,16],[5,14],[4,13],[3,13],[1,14],[0,16],[0,19],[1,21],[3,22],[5,22],[7,21],[8,20],[10,17]], width: 12 },
    'f': { main: [[12,1],[10,1],[8,2],[7,4],[6,8],[6,22]], crossbar: [[3,14],[10,14]], width: 14 },
    'g': { main: [[15,13],[15,27],[14,30],[12,31],[9,31],[7,30],[15,16],[13,14],[11,13],[8,13],[6,14],[4,16],[3,19],[3,21],[4,22],[6,22],[9,21],[11,20],[15,16],[15,19],[15,22],[16,22],[18,21],[19,20],[21,17]], width: 23, descender: true },
    'h': { main: [[4,1],[2,3],[0,8],[0,22],[0,15],[2,14],[5,13],[7,13],[9,14],[10,16],[10,19],[9,22],[10,22],[12,21],[13,20],[15,17]], width: 17 },
    'i': { main: [[4,13],[2,14],[0,17],[0,19],[1,21],[3,22],[5,22],[7,21],[8,20],[10,17]], dot: [4,7], width: 12 },
    'j': { main: [[6,13],[4,14],[2,17],[2,19],[3,21],[5,22],[7,22],[9,21],[10,19],[10,14],[9,22],[9,27],[8,30],[6,31],[3,31],[1,30]], dot: [6,7], width: 12, descender: true },
    'k': { main: [[4,1],[2,3],[0,8],[0,22],[0,18],[5,14],[8,13],[10,13],[4,17],[6,19],[8,22],[9,22],[11,21],[12,20],[14,17]], width: 16 },
    'l': { main: [[6,1],[4,3],[2,8],[1,13],[0,19],[0,21],[1,22],[3,22],[5,21],[6,20],[8,17]], width: 10 },
    'm': { main: [[4,13],[2,14],[0,17],[0,22],[0,16],[2,14],[4,13],[6,13],[8,14],[9,17],[9,22],[9,16],[11,14],[13,13],[15,13],[17,14],[18,17],[18,19],[17,22],[18,22],[20,21],[21,20],[23,17]], width: 25 },
    'n': { main: [[4,13],[2,14],[0,17],[0,22],[0,16],[2,14],[4,13],[6,13],[9,14],[10,17],[10,19],[9,22],[10,22],[12,21],[13,20],[15,17]], width: 17 },
    'o': { main: [[5,13],[3,14],[1,16],[0,19],[0,21],[1,22],[3,22],[6,21],[8,19],[9,16],[9,14],[8,13],[6,13],[4,14],[2,17],[2,19],[3,21],[5,22],[8,22],[10,21],[11,20],[13,17]], width: 15 },
    'p': { main: [[4,13],[2,14],[0,17],[0,31],[0,16],[2,14],[5,13],[7,13],[9,14],[10,16],[10,19],[9,21],[7,22],[4,22],[2,21],[0,19]], width: 12, descender: true },
    'q': { main: [[11,13],[11,31],[11,16],[9,14],[7,13],[4,13],[2,14],[1,16],[1,19],[2,21],[4,22],[7,22],[9,21],[11,19],[12,22],[13,22],[15,21],[16,20],[18,17]], width: 20, descender: true },
    'r': { main: [[4,13],[2,14],[0,17],[0,22],[0,18],[1,16],[3,14],[5,13],[8,13],[10,14]], width: 12 },
    's': { main: [[10,14],[9,13],[6,13],[3,14],[2,15],[2,16],[3,17],[6,18],[8,19],[9,20],[9,21],[8,22],[5,22],[2,21],[1,20],[0,17]], width: 12 },
    't': { main: [[6,1],[4,8],[3,13],[2,17],[2,20],[3,22],[5,22],[7,21],[8,20],[10,17]], crossbar: [[1,13],[8,13]], width: 12 },
    'u': { main: [[4,13],[2,14],[0,17],[0,19],[1,21],[3,22],[6,22],[8,21],[10,19],[14,13],[12,14],[10,17],[10,19],[9,22],[10,22],[12,21],[13,20],[15,17]], width: 17 },
    'v': { main: [[3,13],[1,14],[0,17],[1,20],[3,22],[5,22],[7,20],[11,13],[9,14],[7,17],[7,19],[6,22],[7,22],[9,21],[10,20],[12,17]], width: 14 },
    'w': { main: [[4,13],[2,14],[0,17],[0,19],[1,21],[3,22],[5,22],[6,21],[7,18],[10,13],[8,14],[7,17],[7,22],[10,13],[12,13],[13,14],[14,17],[14,19],[13,22],[14,22],[16,21],[17,20],[19,17]], width: 21 },
    'x': { main: [[2,13],[0,14],[4,22],[5,22],[7,21],[8,20],[10,17]], cross: [[10,13],[8,14],[2,22]], width: 12 },
    'y': { main: [[3,13],[1,14],[0,17],[1,20],[3,22],[5,22],[7,20],[11,13],[9,14],[7,17],[7,19],[6,22],[5,27],[3,30],[1,31],[0,31]], width: 13, descender: true },
    'z': { main: [[0,13],[10,13],[8,14],[4,22],[0,22],[4,22],[6,21],[7,20],[9,17]], width: 12 },
    ' ': { main: [], width: 8 },
    '.': { main: [[1,20],[1,22]], width: 4 },
    ',': { main: [[2,20],[1,22],[0,25]], width: 4 },
    '!': { main: [[2,1],[2,16]], dot: [2,20], width: 6 },
    '?': { main: [[1,5],[2,3],[4,2],[6,2],[8,3],[9,5],[9,7],[8,9],[6,11],[5,13],[5,16]], dot: [5,20], width: 11 }
};

// Convert raw Hershey cursive to normalized vF format
function convertHersheyCursiveToVF() {
    const result = {};

    for (const [char, data] of Object.entries(HERSHEY_CURSIVE_RAW)) {
        if (char === ' ') {
            result[' '] = {
                path: [],
                entry: { x: 0, y: 0.7, angle: 0 },
                exit: { x: 1, y: 0.7, angle: 0 },
                width: 0.35
            };
            continue;
        }

        const points = data.main;
        if (!points || points.length < 2) {
            // Handle dots and simple punctuation
            result[char] = {
                path: [[0.5, 0.85], [0.5, 0.95]],
                entry: { x: 0.5, y: 0.85, angle: 90 },
                exit: { x: 0.5, y: 0.95, angle: 90 },
                width: 0.25
            };
            if (data.dot) {
                result[char].dot = [0.5, 0.15];
            }
            continue;
        }

        // Find bounding box
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        for (const [x, y] of points) {
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
        }

        const width = maxX - minX || 1;
        const height = maxY - minY || 1;

        // Normalize to 0-1 with padding
        const pad = 0.05;
        const scale = 1 - 2 * pad;
        const normalized = points.map(([x, y]) => [
            pad + ((x - minX) / width) * scale,
            pad + ((y - minY) / height) * scale
        ]);

        // Calculate entry/exit angles
        const first = normalized[0];
        const second = normalized[1];
        const last = normalized[normalized.length - 1];
        const secondLast = normalized[normalized.length - 2];

        const entryAngle = Math.atan2(second[1] - first[1], second[0] - first[0]) * 180 / Math.PI;
        const exitAngle = Math.atan2(last[1] - secondLast[1], last[0] - secondLast[0]) * 180 / Math.PI;

        // Calculate width ratio (relative to standard letter width)
        const widthRatio = Math.min(1.1, Math.max(0.45, data.width / 18));

        result[char] = {
            path: normalized,
            entry: { x: first[0], y: first[1], angle: entryAngle },
            exit: { x: last[0], y: last[1], angle: exitAngle },
            width: widthRatio
        };

        // Handle secondary strokes
        if (data.dot) {
            const dotNormY = pad + ((data.dot[1] - minY) / height) * scale;
            const dotNormX = pad + ((data.dot[0] - minX) / width) * scale;
            result[char].dot = [dotNormX, Math.min(0.3, dotNormY)];
        }
        if (data.crossbar) {
            result[char].crossbar = data.crossbar.map(([x, y]) => [
                pad + ((x - minX) / width) * scale,
                pad + ((y - minY) / height) * scale
            ]);
        }
        if (data.cross) {
            result[char].path2 = data.cross.map(([x, y]) => [
                pad + ((x - minX) / width) * scale,
                pad + ((y - minY) / height) * scale
            ]);
        }
        if (data.descender) {
            result[char].descender = true;
        }
    }

    return result;
}

const FONT_HERSHEY = convertHersheyCursiveToVF();

const FONTS = { 'Smooth': FONT_SMOOTH, 'Angular': FONT_ANGULAR, 'Cursive': FONT_HERSHEY };
const FONT_NAMES = ['Smooth', 'Angular', 'Cursive'];

// ============================================
// HASH & TRAIT GENERATION
// ============================================

function generateHash(seed) {
    const pairs = [];
    let s = (Math.abs(seed) ^ 0xDEADBEEF) >>> 0;
    for (let i = 0; i < 32; i++) {
        s ^= s << 13;
        s ^= s >>> 17;
        s ^= s << 5;
        s = s >>> 0;
        pairs.push(s % 256);
    }
    return pairs;
}

function extractTraits(decPairs) {
    const styleVal = decPairs[31];
    let type = styleVal >= 251 ? 'Pipe' :
               styleVal >= 239 ? 'Bold' :
               styleVal >= 219 ? 'Ribbed' :
               styleVal >= 192 ? 'Fuzzy' :
               styleVal >= 162 ? 'Slinky' : 'Normal';

    const hyperRainbow = decPairs[28] <= 2;
    const startColor = decPairs[29];
    const reverse = decPairs[30] < 128;
    const spread = hyperRainbow ? 0.5 : Math.round(5 + (decPairs[28] / 255) * 45);

    let steps;
    if (type === 'Slinky' || type === 'Pipe') {
        steps = 50;  // Per original spec
    } else if (type === 'Fuzzy') {
        steps = 250 + Math.floor((decPairs[23] / 255) * 150);
    } else {
        steps = 200;  // Per original spec - dense overlap for Normal/Bold/Ribbed
    }

    return {
        type,
        hyperRainbow,
        startColor,
        reverse,
        spread,
        steps,
        ribbedInterval: Math.floor(4 + (decPairs[24] / 255) * 12),
        ribbedGray: decPairs[25]
    };
}

function createSeededRandom(seed) {
    let s = (seed ^ 0x12345678) >>> 0;
    return () => {
        s ^= s << 13;
        s ^= s >>> 17;
        s ^= s << 5;
        s = s >>> 0;
        return (s % 10000) / 10000;
    };
}

// ============================================
// COLOR UTILITIES
// ============================================

function hsbToRgb(h, s, b) {
    const hue = ((h % 255) + 255) % 255 / 255;
    const sat = s / 255;
    const bri = b / 255;
    let r, g, bl;
    const i = Math.floor(hue * 6);
    const f = hue * 6 - i;
    const p = bri * (1 - sat);
    const q = bri * (1 - f * sat);
    const t = bri * (1 - (1 - f) * sat);
    switch (i % 6) {
        case 0: r = bri; g = t; bl = p; break;
        case 1: r = q; g = bri; bl = p; break;
        case 2: r = p; g = bri; bl = t; break;
        case 3: r = p; g = q; bl = bri; break;
        case 4: r = t; g = p; bl = bri; break;
        case 5: r = bri; g = p; bl = q; break;
    }
    return [Math.round(r * 255), Math.round(g * 255), Math.round(bl * 255)];
}

// ============================================
// CATMULL-ROM SPLINE
// ============================================

function curvePoint(p0, p1, p2, p3, t) {
    const t2 = t * t;
    const t3 = t2 * t;
    return 0.5 * ((2 * p1) + (-p0 + p2) * t + (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 + (-p0 + 3 * p1 - 3 * p2 + p3) * t3);
}

// ============================================
// CONNECTOR GENERATION
// ============================================

function generateConnector(exitInfo, entryInfo, exitX, entryX, letterHeight) {
    const gap = entryX - exitX;
    if (gap <= 0) return [];
    const startY = exitInfo.y * letterHeight;
    const endY = entryInfo.y * letterHeight;
    if (gap < letterHeight * 0.15) {
        return [[exitX, startY], [entryX, endY]];
    }
    const midX = exitX + gap * 0.5;
    const midY = Math.min(startY, endY) - gap * 0.1;
    return [[exitX, startY], [midX, midY], [entryX, endY]];
}

// ============================================
// MAIN RENDER FUNCTION
// ============================================

function render() {
    const width = canvas.width;
    const height = canvas.height;

    ctx.fillStyle = BACKGROUNDS[state.bgIndex];
    ctx.fillRect(0, 0, width, height);

    const decPairs = generateHash(state.seed);
    let traits = extractTraits(decPairs);
    if (state.forceType !== 'Auto') {
        traits = { ...traits, type: state.forceType };
    }

    const activeFont = FONTS[state.fontStyle] || FONT_SMOOTH;
    const { type, startColor, reverse, spread, steps, ribbedInterval, ribbedGray } = traits;
    const random = createSeededRandom(state.seed);
    const animStartColor = (startColor + state.animOffset) % 255;

    if (!state.text.trim()) {
        updateTraits(traits, animStartColor, animStartColor);
        return;
    }

    // Calculate layout
    const padding = 40;
    const availableWidth = width - padding * 2;
    let totalWidthUnits = 0;

    for (const c of state.text) {
        const letter = activeFont[c];
        if (letter) {
            const isNarrow = 'iljt1'.includes(c);
            totalWidthUnits += letter.width + 0.18 + (isNarrow ? 0.08 : 0);
        }
    }
    totalWidthUnits -= 0.18;

    if (totalWidthUnits <= 0) {
        updateTraits(traits, animStartColor, animStartColor);
        return;
    }

    const baseWidth = Math.min(availableWidth / totalWidthUnits, 90);
    const hasDescender = /[gjpqy,fQ]/.test(state.text);
    const letterHeight = Math.min(height - padding * 2, baseWidth * 1.15);
    const totalPixelWidth = totalWidthUnits * baseWidth;
    const descenderOffset = hasDescender ? letterHeight * 0.2 : 0;
    const startX = (width - totalPixelWidth) / 2;
    const startY = (height - letterHeight) / 2 - descenderOffset;

    // Circle sizes per original Chromie Squiggle spec
    const circleSize = type === 'Bold' ? letterHeight / 8 :
                       type === 'Slinky' ? letterHeight / 10 :
                       type === 'Pipe' ? letterHeight / 10 :
                       type === 'Fuzzy' ? letterHeight / 22 :
                       letterHeight / 13;  // Normal, Ribbed

    // Build paths - one continuous path per word with smooth connectors
    const wordPaths = [];
    let currentPath = [];
    const crossbars = [];
    const dots = [];
    const secondPaths = [];
    let currentX = startX;
    let lastPoint = null;  // Track ACTUAL last point, not metadata

    // Baseline Y for connectors (slightly below letter baseline)
    const baselineY = startY + letterHeight * 0.95;

    for (let i = 0; i < state.text.length; i++) {
        const char = state.text[i];
        const letter = activeFont[char];
        if (!letter) continue;

        const letterWidth = letter.width * baseWidth;
        const isNarrow = 'iljt1'.includes(char);
        const spacing = (0.18 + (isNarrow ? 0.08 : 0)) * baseWidth;

        if (char === ' ') {
            if (currentPath.length >= 2) wordPaths.push(currentPath);
            currentPath = [];
            lastPoint = null;
            currentX += letterWidth + spacing;
            continue;
        }

        if (!letter.path || letter.path.length === 0) {
            currentX += letterWidth + spacing;
            lastPoint = null;
            continue;
        }

        // Transform letter path to canvas coordinates
        const transformedPath = letter.path.map(pt => [
            currentX + pt[0] * letterWidth,
            startY + pt[1] * letterHeight
        ]);

        const firstPt = transformedPath[0];

        // Add smooth connector from previous letter's ACTUAL endpoint
        if (lastPoint) {
            const midX = (lastPoint[0] + firstPt[0]) / 2;
            // Connector curves down toward baseline then up to next letter
            currentPath.push([
                lastPoint[0] + (midX - lastPoint[0]) * 0.3,
                lastPoint[1] + (baselineY - lastPoint[1]) * 0.3
            ]);
            currentPath.push([midX, baselineY]);
            currentPath.push([
                midX + (firstPt[0] - midX) * 0.7,
                baselineY + (firstPt[1] - baselineY) * 0.7
            ]);
        }

        // Add all points from this letter
        for (const pt of transformedPath) {
            currentPath.push(pt);
        }

        // Track ACTUAL last point for next connector
        lastPoint = transformedPath[transformedPath.length - 1];

        // Collect secondary elements
        if (letter.crossbar) {
            crossbars.push(letter.crossbar.map(pt => [
                currentX + pt[0] * letterWidth,
                startY + pt[1] * letterHeight
            ]));
        }
        if (letter.dot) {
            dots.push([
                currentX + letter.dot[0] * letterWidth,
                startY + letter.dot[1] * letterHeight
            ]);
        }
        if (letter.path2) {
            secondPaths.push(letter.path2.map(pt => [
                currentX + pt[0] * letterWidth,
                startY + pt[1] * letterHeight
            ]));
        }

        currentX += letterWidth + spacing;
    }

    if (currentPath.length >= 2) wordPaths.push(currentPath);

    // Combine all paths
    const allPaths = [...wordPaths, ...crossbars, ...secondPaths];

    // Render paths using LINEAR interpolation (not Catmull-Rom which creates wild curves)
    let colorCounter = 0;

    for (const pathPoints of allPaths) {
        if (pathPoints.length < 2) continue;

        // Calculate total path length for even distribution
        let totalLength = 0;
        const segLengths = [];
        for (let i = 0; i < pathPoints.length - 1; i++) {
            const dx = pathPoints[i + 1][0] - pathPoints[i][0];
            const dy = pathPoints[i + 1][1] - pathPoints[i][1];
            const len = Math.sqrt(dx * dx + dy * dy);
            segLengths.push(len);
            totalLength += len;
        }

        // Distribute steps evenly along path length
        const totalSteps = Math.max(steps, Math.floor(totalLength / 2));
        let pathStep = 0;

        for (let step = 0; step <= totalSteps; step++) {
            const targetDist = (step / totalSteps) * totalLength;

            // Find which segment this distance falls into
            let accumulated = 0;
            let segIdx = 0;
            for (let i = 0; i < segLengths.length; i++) {
                if (accumulated + segLengths[i] >= targetDist) {
                    segIdx = i;
                    break;
                }
                accumulated += segLengths[i];
                segIdx = i;
            }

            // Interpolate within segment
            const segStart = pathPoints[segIdx];
            const segEnd = pathPoints[Math.min(segIdx + 1, pathPoints.length - 1)];
            const segLen = segLengths[segIdx] || 1;
            const t = Math.min(1, (targetDist - accumulated) / segLen);

            const x = segStart[0] + (segEnd[0] - segStart[0]) * t;
            const y = segStart[1] + (segEnd[1] - segStart[1]) * t;

                const pathProgress = pathStep / totalSteps;
                const taper = 0.7 + 0.3 * Math.sin(pathProgress * Math.PI);
                const taperSize = circleSize * taper;

                const hue = reverse
                    ? 255 - (((colorCounter / spread) + animStartColor) % 255)
                    : (((colorCounter / spread) + animStartColor) % 255);
                const [r, g, b] = hsbToRgb(hue, 255, 255);

                switch (type) {
                    case 'Normal':
                    case 'Bold':
                        ctx.beginPath();
                        ctx.arc(x, y, taperSize, 0, Math.PI * 2);
                        ctx.fillStyle = `rgb(${r},${g},${b})`;
                        ctx.fill();
                        break;

                    case 'Ribbed':
                        ctx.beginPath();
                        ctx.arc(x, y, taperSize, 0, Math.PI * 2);
                        ctx.fillStyle = `rgb(${r},${g},${b})`;
                        ctx.fill();
                        if (colorCounter % ribbedInterval === 0) {
                            ctx.beginPath();
                            ctx.arc(x, y, taperSize * 1.1, 0, Math.PI * 2);
                            ctx.strokeStyle = `rgb(${ribbedGray},${ribbedGray},${ribbedGray})`;
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                        break;

                    case 'Slinky':
                        ctx.beginPath();
                        ctx.arc(x, y, taperSize, 0, Math.PI * 2);
                        ctx.strokeStyle = `rgb(${r},${g},${b})`;
                        ctx.lineWidth = 2.5;
                        ctx.stroke();
                        break;

                    case 'Pipe':
                        ctx.beginPath();
                        ctx.arc(x, y, taperSize * 1.4, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(x, y, taperSize, 0, Math.PI * 2);
                        ctx.strokeStyle = `rgb(${r},${g},${b})`;
                        ctx.lineWidth = 2.5;
                        ctx.stroke();
                        break;

                    case 'Fuzzy':
                        const fuzzSpread = taperSize * 1.2;
                        const fx = x + (random() - 0.5) * fuzzSpread;
                        const fy = y + (random() - 0.5) * fuzzSpread;
                        const particleSize = taperSize * 0.3 + random() * taperSize * 0.4;
                        ctx.beginPath();
                        ctx.arc(fx, fy, particleSize, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(${r},${g},${b},0.08)`;
                        ctx.fill();
                        break;
                }

                colorCounter++;
                pathStep++;
            }
    }

    // Draw dots
    for (let d = 0; d < dots.length; d++) {
        const dot = dots[d];
        const dotHueOffset = colorCounter + d * spread * spread;
        const hue = reverse
            ? 255 - (((dotHueOffset / spread) + animStartColor) % 255)
            : (((dotHueOffset / spread) + animStartColor) % 255);
        const [r, g, b] = hsbToRgb(hue, 255, 255);
        const dotSize = circleSize * 0.7;

        switch (type) {
            case 'Normal':
            case 'Bold':
                for (let c = 0; c < 12; c++) {
                    const ox = (random() - 0.5) * dotSize * 0.5;
                    const oy = (random() - 0.5) * dotSize * 0.5;
                    ctx.beginPath();
                    ctx.arc(dot[0] + ox, dot[1] + oy, dotSize * 0.85, 0, Math.PI * 2);
                    ctx.fillStyle = `rgb(${r},${g},${b})`;
                    ctx.fill();
                }
                break;

            case 'Slinky':
                for (let c = 0; c < 5; c++) {
                    const ox = (random() - 0.5) * dotSize * 0.4;
                    const oy = (random() - 0.5) * dotSize * 0.4;
                    ctx.beginPath();
                    ctx.arc(dot[0] + ox, dot[1] + oy, dotSize * 0.9, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgb(${r},${g},${b})`;
                    ctx.lineWidth = 2.5;
                    ctx.stroke();
                }
                break;

            case 'Pipe':
                for (let c = 0; c < 12; c++) {
                    const ox = (random() - 0.5) * dotSize * 0.5;
                    const oy = (random() - 0.5) * dotSize * 0.5;
                    ctx.beginPath();
                    ctx.arc(dot[0] + ox, dot[1] + oy, dotSize * 1.0, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(0,0,0,0.6)';
                    ctx.fill();
                }
                for (let c = 0; c < 10; c++) {
                    const ox = (random() - 0.5) * dotSize * 0.4;
                    const oy = (random() - 0.5) * dotSize * 0.4;
                    ctx.beginPath();
                    ctx.arc(dot[0] + ox, dot[1] + oy, dotSize * 0.7, 0, Math.PI * 2);
                    ctx.fillStyle = `rgb(${r},${g},${b})`;
                    ctx.fill();
                }
                break;

            case 'Fuzzy':
                for (let f = 0; f < 80; f++) {
                    const fuzzSpread = dotSize * 2.5;
                    const fx = dot[0] + (random() - 0.5) * fuzzSpread;
                    const fy = dot[1] + (random() - 0.5) * fuzzSpread;
                    const particleSize = dotSize * 0.15 + random() * dotSize * 0.4;
                    ctx.beginPath();
                    ctx.arc(fx, fy, particleSize, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${r},${g},${b},0.08)`;
                    ctx.fill();
                }
                break;

            case 'Ribbed':
                for (let c = 0; c < 5; c++) {
                    const ox = (random() - 0.5) * dotSize * 0.4;
                    const oy = (random() - 0.5) * dotSize * 0.4;
                    ctx.beginPath();
                    ctx.arc(dot[0] + ox, dot[1] + oy, dotSize * 0.9, 0, Math.PI * 2);
                    ctx.fillStyle = `rgb(${r},${g},${b})`;
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(dot[0] + ox, dot[1] + oy, dotSize * 1.0, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgb(${ribbedGray},${ribbedGray},${ribbedGray})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                break;

            default:
                ctx.beginPath();
                ctx.arc(dot[0], dot[1], dotSize, 0, Math.PI * 2);
                ctx.fillStyle = `rgb(${r},${g},${b})`;
                ctx.fill();
        }
    }

    const endHue = reverse
        ? 255 - (((colorCounter / spread) + animStartColor) % 255)
        : (((colorCounter / spread) + animStartColor) % 255);

    updateTraits(traits, animStartColor, endHue);
}

// ============================================
// DRAWING ANIMATION
// ============================================

let cachedPaths = null;
let cachedRenderParams = null;

function startDrawAnimation() {
    if (state.drawAnimating) {
        stopDrawAnimation();
        return;
    }
    state.drawAnimating = true;
    state.drawProgress = 0;
    document.getElementById('animateBtn').textContent = '\u23F9';
    document.getElementById('animateBtn').classList.add('playing');
    buildPathCache();
    animateDrawing();
}

function stopDrawAnimation() {
    state.drawAnimating = false;
    document.getElementById('animateBtn').textContent = '\u25B6';
    document.getElementById('animateBtn').classList.remove('playing');
    render();
}

function buildPathCache() {
    const width = canvas.width, height = canvas.height;
    const decPairs = generateHash(state.seed);
    let traits = extractTraits(decPairs);
    if (state.forceType !== 'Auto') traits = { ...traits, type: state.forceType };
    const activeFont = FONTS[state.fontStyle] || FONT_SMOOTH;
    const { type, startColor, reverse, spread, steps, ribbedInterval, ribbedGray } = traits;
    const animStartColor = (startColor + state.animOffset) % 255;

    if (!state.text.trim()) { cachedPaths = null; return; }

    const padding = 40, availableWidth = width - padding * 2;
    let totalWidthUnits = 0;
    for (const c of state.text) {
        const letter = activeFont[c];
        if (letter) {
            const isNarrow = 'iljt1'.includes(c);
            totalWidthUnits += letter.width + 0.18 + (isNarrow ? 0.08 : 0);
        }
    }
    totalWidthUnits -= 0.18;

    const baseWidth = Math.min(availableWidth / totalWidthUnits, 90);
    const hasDescender = /[gjpqy,]/.test(state.text);
    const letterHeight = Math.min(height - padding * 2, baseWidth * 1.15);
    const descenderOffset = hasDescender ? letterHeight * 0.15 : 0;
    const startX = (width - totalWidthUnits * baseWidth) / 2;
    const startY = (height - letterHeight) / 2 - descenderOffset / 2;
    const circleSize = type === 'Bold' ? letterHeight / 8 : type === 'Slinky' ? letterHeight / 10 : type === 'Pipe' ? letterHeight / 10 : type === 'Fuzzy' ? letterHeight / 22 : letterHeight / 13;

    let wordPaths = [], currentPath = [], prevExit = null, prevExitX = 0, currentX = startX;
    const crossbars = [], dots = [], secondPaths = [];

    for (let i = 0; i < state.text.length; i++) {
        const char = state.text[i], letter = activeFont[char];
        if (!letter) continue;
        const letterWidth = letter.width * baseWidth;
        const isNarrow = 'iljt1'.includes(char);
        const spacing = (0.18 + (isNarrow ? 0.08 : 0)) * baseWidth;
        if (char === ' ') { if (currentPath.length >= 2) wordPaths.push(currentPath); currentPath = []; prevExit = null; currentX += letterWidth + spacing; continue; }
        if (!letter.path || letter.path.length === 0) { currentX += letterWidth + spacing; prevExit = null; continue; }
        if (prevExit && letter.entry) { const entryX = currentX + letter.entry.x * letterWidth; const connector = generateConnector(prevExit, letter.entry, prevExitX, entryX, letterHeight); for (const pt of connector) currentPath.push([pt[0], startY + pt[1]]); }
        for (const pt of letter.path) currentPath.push([currentX + pt[0] * letterWidth, startY + pt[1] * letterHeight]);
        if (letter.crossbar) crossbars.push(letter.crossbar.map(pt => [currentX + pt[0] * letterWidth, startY + pt[1] * letterHeight]));
        if (letter.dot) dots.push([currentX + letter.dot[0] * letterWidth, startY + letter.dot[1] * letterHeight]);
        if (letter.path2) secondPaths.push(letter.path2.map(pt => [currentX + pt[0] * letterWidth, startY + pt[1] * letterHeight]));
        if (letter.exit) { prevExit = letter.exit; prevExitX = currentX + letter.exit.x * letterWidth; } else { prevExit = null; }
        currentX += letterWidth + spacing;
    }
    if (currentPath.length >= 2) wordPaths.push(currentPath);

    let mainPaths = [...wordPaths, ...secondPaths];

    let mainCircles = 0;
    for (const pathPoints of mainPaths) {
        if (pathPoints.length < 2) continue;
        const padded = [pathPoints[0], ...pathPoints, pathPoints[pathPoints.length - 1]];
        mainCircles += (padded.length - 3) * (steps + 1);
    }

    let crossbarCircles = 0;
    for (const pathPoints of crossbars) {
        if (pathPoints.length < 2) continue;
        const padded = [pathPoints[0], ...pathPoints, pathPoints[pathPoints.length - 1]];
        crossbarCircles += (padded.length - 3) * (steps + 1);
    }

    cachedPaths = mainPaths;
    cachedRenderParams = { type, startColor, reverse, spread, steps, ribbedInterval, ribbedGray, circleSize, mainCircles, crossbarCircles, crossbars, dots, animStartColor };
}

function animateDrawing() {
    if (!state.drawAnimating || !cachedPaths) return;

    const { type, startColor, reverse, spread, steps, ribbedInterval, ribbedGray, circleSize, mainCircles, crossbarCircles, crossbars, dots, animStartColor } = cachedRenderParams;
    const random = createSeededRandom(state.seed);
    const speed = state.drawSpeed;
    const circlesToDraw = Math.floor(state.drawProgress);
    const avgCirclesPerLetter = mainCircles / Math.max(state.text.replace(/ /g, '').length, 1);
    const circlesPerDot = Math.floor(avgCirclesPerLetter * 0.4);
    const totalCircles = mainCircles + crossbarCircles + dots.length * circlesPerDot;

    ctx.fillStyle = BACKGROUNDS[state.bgIndex];
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    let colorCounter = 0, circleCount = 0;

    // Phase 1: Main paths
    outer: for (const pathPoints of cachedPaths) {
        if (pathPoints.length < 2) continue;
        const padded = [pathPoints[0], ...pathPoints, pathPoints[pathPoints.length - 1]];
        const totalSegs = padded.length - 3, totalSteps = totalSegs * steps;
        let pathStep = 0;

        for (let seg = 0; seg < padded.length - 3; seg++) {
            const [p0, p1, p2, p3] = [padded[seg], padded[seg + 1], padded[seg + 2], padded[seg + 3]];
            for (let i = 0; i <= steps; i++) {
                if (circleCount >= Math.min(circlesToDraw, mainCircles)) break outer;
                const t = i / steps;
                const x = curvePoint(p0[0], p1[0], p2[0], p3[0], t);
                const y = curvePoint(p0[1], p1[1], p2[1], p3[1], t);
                const pathProgress = pathStep / totalSteps;
                const taper = 0.7 + 0.3 * Math.sin(pathProgress * Math.PI);
                const taperSize = circleSize * taper;
                const hue = reverse ? 255 - (((colorCounter / spread) + animStartColor) % 255) : (((colorCounter / spread) + animStartColor) % 255);
                const [r, g, b] = hsbToRgb(hue, 255, 255);

                switch (type) {
                    case 'Normal': case 'Bold':
                        ctx.beginPath(); ctx.arc(x, y, taperSize, 0, Math.PI * 2);
                        ctx.fillStyle = `rgb(${r},${g},${b})`; ctx.fill(); break;
                    case 'Slinky':
                        ctx.beginPath(); ctx.arc(x, y, taperSize, 0, Math.PI * 2);
                        ctx.strokeStyle = `rgb(${r},${g},${b})`; ctx.lineWidth = 2.5; ctx.stroke(); break;
                    case 'Pipe':
                        ctx.beginPath(); ctx.arc(x, y, taperSize * 1.4, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 1.5; ctx.stroke();
                        ctx.beginPath(); ctx.arc(x, y, taperSize, 0, Math.PI * 2);
                        ctx.strokeStyle = `rgb(${r},${g},${b})`; ctx.lineWidth = 2.5; ctx.stroke(); break;
                    case 'Ribbed':
                        ctx.beginPath(); ctx.arc(x, y, taperSize, 0, Math.PI * 2);
                        ctx.fillStyle = `rgb(${r},${g},${b})`; ctx.fill();
                        if (colorCounter % ribbedInterval === 0) {
                            ctx.beginPath(); ctx.arc(x, y, taperSize * 1.1, 0, Math.PI * 2);
                            ctx.strokeStyle = `rgb(${ribbedGray},${ribbedGray},${ribbedGray})`; ctx.lineWidth = 2; ctx.stroke();
                        } break;
                    case 'Fuzzy':
                        const fuzzSpread = taperSize * 1.2;
                        const fx = x + (random() - 0.5) * fuzzSpread;
                        const fy = y + (random() - 0.5) * fuzzSpread;
                        const particleSize = taperSize * 0.3 + random() * taperSize * 0.4;
                        ctx.beginPath(); ctx.arc(fx, fy, particleSize, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(${r},${g},${b},0.08)`; ctx.fill(); break;
                }
                colorCounter++; pathStep++; circleCount++;
            }
        }
    }

    // Phase 2: Crossbars
    if (circlesToDraw > mainCircles) {
        const crossbarProgress = circlesToDraw - mainCircles;
        let cbCount = 0;
        outer2: for (const pathPoints of crossbars) {
            if (pathPoints.length < 2) continue;
            const padded = [pathPoints[0], ...pathPoints, pathPoints[pathPoints.length - 1]];
            const totalSegs = padded.length - 3, totalSteps = totalSegs * steps;
            let pathStep = 0;
            for (let seg = 0; seg < padded.length - 3; seg++) {
                const [p0, p1, p2, p3] = [padded[seg], padded[seg + 1], padded[seg + 2], padded[seg + 3]];
                for (let i = 0; i <= steps; i++) {
                    if (cbCount >= crossbarProgress) break outer2;
                    const t = i / steps;
                    const x = curvePoint(p0[0], p1[0], p2[0], p3[0], t);
                    const y = curvePoint(p0[1], p1[1], p2[1], p3[1], t);
                    const pathProgress = pathStep / totalSteps;
                    const taper = 0.7 + 0.3 * Math.sin(pathProgress * Math.PI);
                    const taperSize = circleSize * taper;
                    const hue = reverse ? 255 - (((colorCounter / spread) + animStartColor) % 255) : (((colorCounter / spread) + animStartColor) % 255);
                    const [r, g, b] = hsbToRgb(hue, 255, 255);

                    switch (type) {
                        case 'Normal': case 'Bold':
                            ctx.beginPath(); ctx.arc(x, y, taperSize, 0, Math.PI * 2);
                            ctx.fillStyle = `rgb(${r},${g},${b})`; ctx.fill(); break;
                        case 'Slinky':
                            ctx.beginPath(); ctx.arc(x, y, taperSize, 0, Math.PI * 2);
                            ctx.strokeStyle = `rgb(${r},${g},${b})`; ctx.lineWidth = 2.5; ctx.stroke(); break;
                        default:
                            ctx.beginPath(); ctx.arc(x, y, taperSize, 0, Math.PI * 2);
                            ctx.fillStyle = `rgb(${r},${g},${b})`; ctx.fill(); break;
                    }
                    colorCounter++; pathStep++; cbCount++;
                }
            }
        }
    }

    // Phase 3: Dots
    if (circlesToDraw > mainCircles + crossbarCircles) {
        const dotPhaseProgress = circlesToDraw - mainCircles - crossbarCircles;
        const dotsToShow = Math.floor(dotPhaseProgress / circlesPerDot);

        for (let d = 0; d < Math.min(dotsToShow, dots.length); d++) {
            const dot = dots[d];
            const dotHueOffset = colorCounter + d * spread * spread;
            const hue = reverse ? 255 - (((dotHueOffset / spread) + animStartColor) % 255) : (((dotHueOffset / spread) + animStartColor) % 255);
            const [r, g, b] = hsbToRgb(hue, 255, 255);
            const dotSize = circleSize * 0.7;

            switch (type) {
                case 'Normal': case 'Bold':
                    for (let c = 0; c < 12; c++) {
                        const ox = (random() - 0.5) * dotSize * 0.5;
                        const oy = (random() - 0.5) * dotSize * 0.5;
                        ctx.beginPath(); ctx.arc(dot[0] + ox, dot[1] + oy, dotSize * 0.85, 0, Math.PI * 2);
                        ctx.fillStyle = `rgb(${r},${g},${b})`; ctx.fill();
                    } break;
                case 'Slinky':
                    for (let c = 0; c < 5; c++) {
                        const ox = (random() - 0.5) * dotSize * 0.4;
                        const oy = (random() - 0.5) * dotSize * 0.4;
                        ctx.beginPath(); ctx.arc(dot[0] + ox, dot[1] + oy, dotSize * 0.9, 0, Math.PI * 2);
                        ctx.strokeStyle = `rgb(${r},${g},${b})`; ctx.lineWidth = 2.5; ctx.stroke();
                    } break;
                default:
                    ctx.beginPath(); ctx.arc(dot[0], dot[1], dotSize, 0, Math.PI * 2);
                    ctx.fillStyle = `rgb(${r},${g},${b})`; ctx.fill();
            }
        }
    }

    state.drawProgress += speed * 3;
    if (state.drawProgress >= totalCircles) {
        stopDrawAnimation();
    } else {
        requestAnimationFrame(animateDrawing);
    }
}

// ============================================
// UI FUNCTIONS
// ============================================

function updateTraits(traits, startHue, endHue) {
    const el = document.getElementById('traits');
    if (!traits) { el.innerHTML = ''; return; }
    const [sr, sg, sb] = hsbToRgb(startHue, 255, 255);
    const [er, eg, eb] = hsbToRgb(endHue, 255, 255);
    el.innerHTML = `
        <span><span class="trait-val">${traits.type}</span> ${state.fontStyle}</span>
        <span>spread <span class="trait-val">${traits.spread}</span></span>
        <span>color <span class="trait-val">${Math.round(startHue)}</span>
        <span class="color-dot" style="background:rgb(${sr},${sg},${sb});margin:0 4px"></span>
        &rarr;
        <span class="color-dot" style="background:rgb(${er},${eg},${eb});margin:0 4px"></span>
        <span class="trait-val">${Math.round(endHue)}</span></span>
    `;
}

function updateButtons() {
    document.querySelectorAll('#typeBtns .btn').forEach(btn => {
        btn.classList.toggle('active', btn.textContent === state.forceType);
    });
    document.querySelectorAll('#fontBtns .btn').forEach(btn => {
        btn.classList.toggle('active', btn.textContent === state.fontStyle);
    });
}

function toggleDarkMode() {
    state.darkMode = !state.darkMode;
    document.body.classList.toggle('light-mode', !state.darkMode);
    document.getElementById('modeToggle').textContent = state.darkMode ? '\u2600' : '\u263E';
    state.bgIndex = state.darkMode ? 7 : 0;
    render();
}

function downloadPNG() {
    const link = document.createElement('a');
    link.download = `squigword-${state.text}-${state.seed}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
}

// ============================================
// SETUP
// ============================================

function setup() {
    // Type buttons
    const typeBtns = document.getElementById('typeBtns');
    TYPES.forEach(t => {
        const btn = document.createElement('button');
        btn.className = 'btn';
        btn.textContent = t;
        btn.onclick = () => {
            state.forceType = t;
            updateButtons();
            render();
        };
        typeBtns.appendChild(btn);
    });

    // Font buttons
    const fontBtns = document.getElementById('fontBtns');
    FONT_NAMES.forEach(f => {
        const btn = document.createElement('button');
        btn.className = 'btn';
        btn.textContent = f;
        btn.onclick = () => {
            state.fontStyle = f;
            updateButtons();
            render();
        };
        fontBtns.appendChild(btn);
    });

    // Event listeners
    document.getElementById('textInput').addEventListener('input', (e) => {
        state.text = e.target.value;
        render();
    });

    document.getElementById('seedInput').addEventListener('input', (e) => {
        state.seed = parseInt(e.target.value) || 0;
        render();
    });

    const words = ['Squiggles','Wiggly','Jiggly','Groovy','Loopy','Balloon','Jelly','Giggles','Wobbly','Bubbles'];
    document.getElementById('randWordBtn').addEventListener('click', () => {
        state.text = words[Math.floor(Math.random() * words.length)];
        state.seed = Math.floor(Math.random() * 100000);
        document.getElementById('textInput').value = state.text;
        document.getElementById('seedInput').value = state.seed;
        render();
    });

    document.getElementById('randSeedBtn').addEventListener('click', () => {
        state.seed = Math.floor(Math.random() * 100000);
        document.getElementById('seedInput').value = state.seed;
        render();
    });

    document.getElementById('modeToggle').addEventListener('click', toggleDarkMode);
    document.getElementById('downloadBtn').addEventListener('click', downloadPNG);
    document.getElementById('animateBtn').addEventListener('click', startDrawAnimation);
    document.getElementById('speedSlider').addEventListener('input', (e) => {
        state.drawSpeed = parseInt(e.target.value);
    });

    canvas.addEventListener('click', () => {
        state.bgIndex = (state.bgIndex + 1) % BACKGROUNDS.length;
        render();
    });

    updateButtons();
    render();
}

setup();
</script>
</body>
</html>
